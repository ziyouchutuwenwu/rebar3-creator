#!/usr/bin/env python

import shutil
import os
import string
import sys

#rebar.config
class Config:
    def __init__(self, configFile):
        self.__configFile = configFile

    def replace(self, oldContent, newContent):
        self.makeBakFile()

        bakFile = open(self.getBakFileName(), "r+")
        newFile = open(self.__configFile, "w+")

        for line in bakFile.readlines():
            if( string.find(line,oldContent) != -1 ):
                line = line.replace(oldContent,newContent)
            newFile.write(line)
        bakFile.close()
        self.removeBakFile()
        newFile.close()

    def makeBakFile(self):
        shutil.copyfile(self.__configFile, self.getBakFileName())

    def removeBakFile(self):
        os.remove(self.getBakFileName())

    def getBakFileName(self):
        return self.__configFile + ".bak"

# eunit
class TestSetting:
    def __init__(self, dirPath):
        self.__modulePath = dirPath

    def writeEunitTemplate(self, eunitTemplateFileName):
        self.checkDir()

        moduleName = os.path.splitext(eunitTemplateFileName)[0]
        content = "-module(%s).\r\n" % (moduleName)

        content += "\r\n"
        content += "-include_lib(\"eunit/include/eunit.hrl\").\r\n"
        content += "\r\n"
        content += "simple_test() ->\r\n"
        content += "    ?assert(true)."

        fullPath = os.path.join(self.__modulePath, eunitTemplateFileName)
        file = open(fullPath, "w+")
        file.write(content)
        file.close()

    def writeCtTemplate(self, ctTemplateFileName):
        self.checkDir()

        moduleName = os.path.splitext(ctTemplateFileName)[0]

        content = "%% http://erlang.org/doc/apps/common_test/write_test_chapter.html\r\n"
        content += "-module(%s).\r\n" % (moduleName)

        content += "\r\n"
        content += "-include_lib(\"common_test/include/ct.hrl\").\r\n"
        content += "\r\n"
        content += "-compile(export_all).\r\n"
        content += "\r\n"

        content += "suite() ->\r\n"
        content += "  [\r\n"
        content += "    {timetrap, {seconds, 20}},\r\n"
        content += "      {userdata,[\r\n"
        content += "        {info, \"this is a common test template.\"}\r\n"
        content += "      ]}\r\n"
        content += "  ].\r\n"

        content += "\r\n"
        content += "groups() ->\r\n"
        content += "  [\r\n"
        content += "    {my_group,\r\n"
        content += "      %% [parallel, {repeat, 10}],\r\n"
        content += "      [],\r\n"
        content += "      [test_case1, test_case2]}\r\n"
        content += "  ].\r\n"
        content += "\r\n"
        content += "all() ->\r\n"
        content += "  [\r\n"
        content += "    {group, my_group},\r\n"
        content += "    test_case3\r\n"
        content += "  ].\r\n"
        content += "\r\n"
        content += "init_per_suite(Config) ->\r\n"
        content += "  ct:log(\"init_per_suite~n\"),\r\n"
        content += "  Config.\r\n"
        content += "\r\n"
        content += "end_per_suite(_Config) ->\r\n"
        content += "  ct:log(\"end_per_suite~n\"),\r\n"
        content += "  ok.\r\n"
        content += "\r\n"
        content += "init_per_group(Group, Config) ->\r\n"
        content += "  ct:log(\"init_per_group~p~n\",[Group]),\r\n"
        content += "  Config.\r\n"
        content += "\r\n"
        content += "end_per_group(Group, Config) ->\r\n"
        content += "  ct:log(\"end_per_group~p~n\",[Group]),\r\n"
        content += "  Config.\r\n"
        content += "\r\n"
        content += "init_per_testcase(TestCase, Config) ->\r\n"
        content += "  ct:log(\"init_per_testcase~p~n\",[TestCase]),\r\n"
        content += "  Config.\r\n"
        content += "\r\n"
        content += "end_per_testcase(TestCase, Config) ->\r\n"
        content += "  ct:log(\"end_per_testcase~p~n\",[TestCase]),\r\n"
        content += "  Config.\r\n"
        content += "\r\n"
        content += "%% --------------------------------------------------------\r\n"
        content += "test_case1(_Config) ->\r\n"
        content += "  ct:log(\"in test_case1~n\"),\r\n"
        content += "  {skip, \"Not implemented.\"}.\r\n"
        content += "\r\n"
        content += "test_case2(_Config) ->\r\n"
        content += "  ct:log(\"in test_case2~n\"),\r\n"
        content += "  1=1.\r\n"
        content += "\r\n"
        content += "test_case3(_Config) ->\r\n"
        content += "  ct:log(\"in test_case3~n\"),\r\n"
        content += "  1=1.\r\n"
        content += "\r\n"
        content += "test_case4(_Config) ->\r\n"
        content += "  ct:log(\"in test_case4~n\"),\r\n"
        content += "  1=1."

        fullPath = os.path.join(self.__modulePath, ctTemplateFileName)
        file = open(fullPath, "w+")
        file.write(content)
        file.close()

    def checkDir(self):
        isExisted = os.path.exists(self.__modulePath)
        if not isExisted:
            os.makedirs(self.__modulePath)
        return

class ExampleSetting:
    @staticmethod
    def createDir(examplePath):
        isExists = os.path.exists(examplePath)
        if not isExists:
            os.makedirs(examplePath)
        return

class ScriptUtility:
    @staticmethod
    def createCleanScript(basicPath, scriptName):

        content = "#!/bin/bash\n"
        content += "\n"
        content += "rm -rf ./_build/test\n"
        content += "rebar3 clean"

        fullPath = os.path.join(basicPath, scriptName)
        file = open(fullPath, "w+")
        file.write(content)
        file.close()

# different path
class PathHelper:
    @staticmethod
    def getAppPath(relPath, projectName):
        return os.path.join(relPath, projectName)

    @staticmethod
    def getRebarConfigPath(relPath, projectName, rebarConfigFileName):
        return os.path.join(relPath, projectName, rebarConfigFileName)

    @staticmethod
    def getTestDirPath(relPath, projectName, projectType):
        if projectType == "release":
            return os.path.join(relPath, projectName, "apps", projectName,"test")
        else:
            return os.path.join(relPath, projectName, "test")

    @staticmethod
    def getExamplePath(relPath, projectName, projectType):
        if projectType == "release":
            return os.path.join(relPath, projectName, "apps", projectName, "src", "example")
        else:
            return os.path.join(relPath, projectName, "src", "example")

if __name__ == '__main__':
    if len(sys.argv) == 1:
        print "please input mode, release, app, lib, escript?"
        os._exit(0)

    elif len(sys.argv) == 2:
        print "project_name?"
        os._exit(0)

    projectType = sys.argv[1]
    projectName = sys.argv[2]
    relPath = os.getcwd()

    if projectType == "release":
        os.system('rebar3 new release ' + projectName)
    elif projectType == "app":
        os.system('rebar3 new app ' + projectName)
    elif projectType == "lib":
        os.system('rebar3 new lib ' + projectName)
    elif projectType == "escript":
        os.system('rebar3 new escript ' + projectName)
    else:
        print "not supported"
        os._exit(0)

    configFile = Config(PathHelper.getRebarConfigPath(relPath, projectName, "rebar.config"))

    configFile.replace("{erl_opts, [debug_info]}.",

                       "%%  {erl_opts, [native, {hipe, [verbose]}, debug_info]}. \r\n"
                       + "%%  {erl_opts, [no_debug_info]}. \r\n"
                       + "%%  {erl_opts, [debug_info]}. \r\n"
                       + "\r\n"
                       + "%%  {ok, {_, [{abstract_code, {_, Ac}}]}} = beam_lib:chunks(code:which(a), [abstract_code]). \r\n"
                       + "%%  io:fwrite(\"~s~n\", [erl_prettypr:format(erl_syntax:form_list(Ac))]). \r\n"
                       + "%%  vim ~/.erlang.crypt \r\n"
                       + "%%  [{debug_info, des3_cbc, [], \"12345\"}]. \r\n"
                       + "\r\n"
                       + "%%  ~/.erlang.crypt not needed on compiling, only neened on debugging \r\n"
                       + "%%  {erl_opts, [debug_info,{debug_info_key,{des3_cbc,\"12345\"}}]}. \r\n"
                       + "\r\n"
                       + "%%  ~/.erlang.crypt needed on compiling\r\n"
                       + "{erl_opts, [encrypt_debug_info]}.\n")

    configFile.replace("{deps, []}.",

                       "{deps, [\r\n"
                       + "  {sync, \".*\", {git, \"https://github.com/rustyio/sync\", {branch, \"master\"}}} \r\n"
                       + "%%  {cowboy, \".*\",{git, \"https://github.com/ninenines/cowboy.git\", {branch, \"master\"}}},\r\n"
                       + "%%  {cowboy, \"1.0.4\",{git, \"https://github.com/ninenines/cowboy.git\", {tag, \"1.0.4\"}}}\r\n"
                       + "]}.\r\n"

                       #options for eunit
                       + "\r\n"
                       + "{cover_enabled, true}.\r\n"
                       + "{eunit_opts, [\r\n"
                       + "    verbose, {\r\n"
                       + "        report,{\r\n"
                       + "            eunit_surefire,[\r\n"
                       + "                {dir,\"./_build/test\"}\r\n"
                       + "            ]\r\n"
                       + "        }\r\n"
                       + "    }\r\n"
                       + "]}.\r\n")

    testSetting = TestSetting(PathHelper.getTestDirPath(relPath, projectName, projectType))
    testSetting.writeEunitTemplate("template_eunit_test.erl")
    testSetting.writeCtTemplate("template_SUITE.erl")

    ExampleSetting.createDir(PathHelper.getExamplePath(relPath, projectName, projectType))
    ScriptUtility.createCleanScript(PathHelper.getAppPath(relPath, projectName), "clean.sh")
